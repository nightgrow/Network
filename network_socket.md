# Network
## Network socket
- 두 프로그램이 네트워크를 통해 서로 통신할 수 있도록 양쪽에 생성되는 링크의 단자
- 프로그램이 통신하기 위해 소프트웨어로 작성된 통신의 접속점
- 두 소켓이 연결되면 서로 다른 프로세스끼리 데이터를 전달할 수 있다.
- 요즘에는 인터넷을 사용한 통신이 많기 때문에 인터넷 소켓이라고도 한다.
- TCP와 UDP로 구분한다.

### '소켓'의 의미
1. **데이터 타입**: 파일 디스크립터나 핸들과 유사한 개념으로, 함수를 호출하여 손쉽게 네트워크 통신을 수행할 수 있다.
2. **통신 종단점**: 통신의 출발점과 도착점
3. **네트워크 프로그래밍 인터페이스**: TCP/IP 프로토콜 구조에서 응용 계층과 전송 계층 사이에 위치하는 것 

### 윈도우 소켓
- 버클리 유닉스에서 개발한 소켓을 윈도우 환경에서 사용할 수 있게 만든 것
- 장점
  1. 유닉스 소켓과 소스 코드 수준에서 호환성이 높으므로 기존 코드를 이식하여 활용하기 쉽다.
  2. 가장 널리 사용하므로 여러 운영체제에서 사용할 수 있다.
  3.  TCP/IP 외의 프로토콜도 지원하므로 최소 코드 수정으로 응용 프로그램이 사용할 프로토콜을 변경할 수 있다.
  4. 세부 제어가 가능하며 고성능 네트워크 프로그램을 개발할 수 있다.

- 단점
  1. 주고받는 데이터 형식이나 전송 절차 등을 고려해 프로그래밍 해야하며, 설계 변경 시 코드 수정이 불가피하다.
  2. 서로 다른 바이트 정렬 방식을 사용하거나 데이터 처리 단위가 다른 호스트끼리 통신하리 경우, 응용 프로그램 수준에서 데이터 변환을 처리해야 한다.


### TCP
- 전송 제어 프로토콜
- 데이터의 송수신을 위해 IP를 사용하는 프로토콜이며, UDP에 비해 복잡하지만 신뢰성이 높다.
- 데이터를 여러 개의 패킷으로 나누고 도착지에서는 완전한 데이터로 패킷들을 조립해야 한다.
- 상위층이 넘겨준 데이터를 세그먼트라는 단위로 쪼개어 가공하고 하위층으로 넘겨주며, 자른 세그먼트에 순번을 부여하여 전송, 수신하여 순서가 뒤바뀌는 일이 없도록 하고 있다. 또한 패킷(네트워크 전송의 용량 단위)이 왔다갔다 하며 순번이 뒤바뀌는 경우에도 복구하여 상위층이 신뢰할 수 있는 연결 방식을 제공한다.
- 신뢰성 스트림 서비스라고 부르기도 한다.
- ACK가 오지 않는 경우
    1. 보낸 패킷이 받는 쪽에 도착하지 않아 받는 쪽이 ACK을 보내야 하는 것을 모를 때
    2. ACK가 불안정한 IP 때문에 중간에 유실된 경우  
    일정 시간 ACK가 오지 않으면 패킷을 보내는 쪽에서 다시 보내기(재전송)를 한다. 

#### 특징
- 연결형 서비스로 가상 회선 방식 제공
- 3-way handshaking과정을 통해 연결 설정, 4-way handshaking을 통해 해제

#### 3-Way Handshake/4-Way Handshake
- 3-Way Handshake
![3 Way Handshake](https://t1.daumcdn.net/cfile/tistory/222D873E5815FD142E "3-Way Handshake")
    1. 접속 요청 프로세스가 연결 요청 메시지 전송(SYN)
    2. 접속 요청을 받은 프로세스가 수락(SYN + ACK)
    3. 마지막으로 접속 요청 프로세스가 수락 확인을 보내 연결을 맺음(ACK)
     
   - SYN: 연결 요청, 세션을 설정하는데 사용되며 초기에 시퀀스 번호를 보냄
   - ACK: 보낸 시쿼스 번호에 TCP 계층에서 길이 또는 양을 더한 것과 같은 값을 ACK에 포함하여 전송

- 4-Way Handshake
  ![4 Way Handshake](https://t1.daumcdn.net/cfile/tistory/2678E035537EEE9126 "4-Way Handshake")
    1. 통신을 종료하고자 하는 클라이언트가 서버에게 FIN(클라이언트의 요청) 패킷을 보내고 자신은 FIN_WAIT_1 상태로 대기
    2. FIN 패킷을 받은 서버는 해동 포트를 CLOSE_WAIT로 바꾸고 잘 받았다는 ACK(메세지)를 클라이언트에게 전하고, ACK를 받은 클라이언트는 상태를 FIN_WAIT_2로 변경, 서버에서는 해당 포트에 연결되어 있는 어플리케이션에게 Close() 요청
    3. Close() 요청을 받은 어플리케이션은 종료 프로세스를 진행시켜 최종적으로 close()가 되고 서버는 FIN 패킷을 클라이언트에게 전송 후 LAST_ACK로 상태를 바꿈
    4. FIN_WAIT_2에서 서버가 연결을 종료했다는 신호를 기다리다가 FIN을 받으면 ACK를 서버에 전송하고 TINE_WAIT로 상태 변경, 최종 ACK를 받은 서버는 자신의 포트도 CLOSED로 닫게 됨
  
    - 비정상 종료 상황
        1. CLOSE_WAIT 상태: 어플리케이션에서 close()를 적절하게 처리해주지 못하면, TCP 포트는 CLOSE_WAIT 상태로 계속 남아있게되고, statement에 많아지게 되면 hang(프로그램 수행 중 멈춰서 더 이상 진행이 되지 않는 상황)이 걸려 연결 하지 못하는 경우기 발생한다.
        2. FIN_WAIT_1 상태: 상대방 측에서 커넥션 종료 요청을 했는데, ACK를 받지 못한 상태로 기다리고 있는 것이며, 일정 시간이 지나 Time Out이 되면 자동으로 닫는다.
        3. FIN_WAIT_2 상태: 클라이언트가 서버에 종료를 요청한 후 서버에서 요청을 접수했다고 ACK를 받았지만, 서버에서 종료를 완료했다는 FIN을 받지 못하고 기다리고 있는 상태이며, Time Out이 되면 자동으로 닫는다.  

        이떠한 이유에서 FIN_WAIT_1과 FIN_WAIT_2 상태인 연결이 많이 남아있다면 문제가 발생할 수 있다(메모리 부족으로 인한 소켓 오픈 불가 등). 
     

### UDP
- 데이터를 패킷으로 나누고 재조립하는 과정을 거치지 않으며 데이터를 보내기만 한다.
- 컴퓨터끼리 직접 연결하고자 할 때 UDP를 사용한다.
- Best-effort 에러가 날 수도 있고 재전송이나 순서 뒤바뀜에 대한 대체는 어플리케이션에서 처리해 주어야 한다.
- 속도가 빠르기 때문에 데이터 처리가 신속하고 한 두장의 프레임이 빠져도 보정이 가능하다.
- 비연결성을 가지며 수신측이 제대로 도착하였는지 확인 여부를 보장하지 않는 비신뢰성 서비스이다.